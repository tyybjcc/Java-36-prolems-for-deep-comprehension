# 一. 基本概念
## 1. 测试你的java水平
15个问题：
#### 1. float类型占4个字节，long占8个字节，为什么float类型表示的范围比long类型表示的范围还大？
> 浮点数和整型数的表示方式不同，整型存储的是准确值，浮点数通过类似于科学技术法的形式（符号位1、阶码8、有效数值位23）表示浮点数，具有一定有效位数，对于较大的long值，float只能表示其近似值（值越大，相邻两个值的间隔越大，越不准确）。

#### 2. 使用"+"可以连接两个String对象，是如何实现的？
```java
(new StringBuilder()).append(s1).append(s2).toString();	//oracle实现
( new StringBuilder(String.valueOf(s1)) ).append(s2).toString(s2);//Eclipse对于这种情况的实现
```
对于编译时常量String对象（String常量表达式）的"+"，编译器在编译阶段已经完成。因此，在执行包含"+"的String常量表达式不需要优化。

#### 3. 构造器是否创建了对象？怎样证明这一点？
> 构造器没有创建对象，new操作符创建了对象，构造器负责对象的初始化工作。
> 如何证明：通过构造大量对象时产生空间不足的错误，构造器形参置位，方法体复位。如果最终状态为“复位”，则证明构造器尚未执行。如图：
> ![](http://www.coding.wang/up/php/upload/default/201506/png/1433219169.png)

#### 4. 如果没有在类中显示声明构造器，则编译器会自动生成一个无参构造器，编译器为何要声明一个无参构造器？有什么作用？
> 
1. 为何要声明：1. 编译器通过构造器产生<init>方法执行实例初始化； 2. 子类继承时显式或隐式通过`super()`调用父类构造器；
2. 构造器的作用：一个构造器即使是默认构造器至少完成以下几个工作：
 * 调用父类构造器
 * 执行实例变量声明初始化工作
 * 执行实例初始化块

#### 5. i++与++i有什么不同？仅仅是先加与后加吗？
> i++执行时先将变量i的值压栈，执行完iinc增值指令后，表达式使用的是之前压入栈的值；
> 而++i则没有执行压栈操作，执行完iinc增值指令后使用的是i的值。

#### 6. 移位运算： 5<<35会计算前会进行求余操作吗？ 如果是这样，那么5<<-2的结果是多少呢？

不会进行求余操作，对于整型或提升后为整型的数的移位（包括左移、右移、无符号右移），真实的移位位数不超过32-1位；对于long类型，真实移位位数不超过64-1位。计算方法：
```java
int intRealShiftNum = 0x1f&shiftNum;	//移位位数最低5位有效
int longRealShiftNum = 0x3f&shiftNum;	//移位位数最低6位有效
```

对于移位位数为负数的计算方式相同。（通过按位与操作，真实移位位数为正数）

#### 7. 如果重写了equals方法，为什么还要重写hashCode方法？ 如果没有重写会出现什么问题？
默认的equals方法是对地址的等值比较；hashCode方法是对地址的哈希。String类、基本类型的包装类等类通过重写equals方法就可以比较对象是否相等（而不是对象的引用是不是指向同一地址）。
对于equals比较相等的对象必须返回相等的hashCode，这对于对象的索引和快速查找非常重要。对于Java中Map和Set集合类就是利用这种机制实现的。

#### 8. 从JDK1.7开始，switch语句开始支持String类型，其在底层是如何实现的？
switch对于String的支持是通过java编译器实现的，其底层利用对 String的hashCode 执行switch操作来实现的。
> 注意，由于hashCode可能重复的问题，switch底层对String的实现通过两次switch操作实现的。

```java
String name = "name2";
//manually simulation2(Java36)
byte b = -1;

//第一个switch产生b值
switch(name.hashCode()) {
case 104584966:
	if(name.equals("name1")) {
		b = 0;
	}
	//else if ...	//对于有相同hashCode值的不同字符串，b取不同值
	break;
case 104584967:
	if(name.equals("name2")) {
		b = 1;
	}
	break;
case 104584968:
	if(name.equals("name3")) {
		b = 2;
	}
	break;
}

//第二个switch根据b值模拟代码中的switch语句
switch(b) {
case 0:
	System.out.println("name1");
	break;
case 1:
	System.out.println("name2");
	break;
case 2:
	System.out.println("name3");
	break;
default:
	System.out.println("nameDefault");
}

```


#### 9. 静态方法可否用来重写？重写与隐藏有哪些不同？
不能重写，重写仅针对成员方法。对于静态方法和成员变量（包括静态成员变量和实例成员变量）可以被隐藏。
重写和隐藏的本质区别在于：重写是执行期间**动态绑定**，而隐藏是编译期间根据引用类型**静态绑定**。

#### 10. 为什么不能在静态方法中使用this？this指代当前对象，但是这个所谓的“当前对象”到底在哪里？
静态方法不存在this指针，静态方法也不与具体的实例对象绑定。
this指针本质是编译器将当前对象的指针隐式传入所有构造器和实例方法中（通过他们的第一个参数），因此可以在构造器和实例方法中使用this，而静态方法不可以。


#### 11. 在Java中，类型会在什么时间、什么条件下由JVM加载？加载后一定会初始化吗？
程序执行过程中，只要出现没有加载类的时候，JVM就会加载该类。
可以使用classLoader.loadClass("packageName.className")方法执行类的加载。
类加载一般不会执行初始化工作。

#### 12. 相比C/C++的枚举，Java的没有有什么优势？枚举是怎样实现的？
C/C++的枚举本质上是整型常量，其带来的问题有：魔数、不同枚举间互相赋值、出现枚举允许值意外的值。
Java的枚举实现是通过继承java.lang.Enum类完成的，枚举常量其实是枚举类的final对象，不可以改变其引用（当然外部也不能增加枚举常量）。因此，Java枚举更严格、更清晰、更有利于程序的维护。

#### 13. 为什么String对象要建立常量池？ String常量池有什么好处？
编译器将**String常量表达**式存储在String常量池中，String常量池是String类维护的一块特殊区域。通过String常量池，相同String可以被共享。另外，String常量池是从类的CONSTANT_Utf8_info表中加载String常量的，而CONSTANT_Utf8_info表是在编译期间建立的，编译期间将String常量表达式计算好在执行期间载入可以加速程序的运行。


#### 14. 每个基本类型都对应一个包装类，这些包装类有什么用？
Java是面向对象语言，包装类使基本类型与其它类型有更好的兼容性。Java中一些类库不支持基本类型，典型的例子是集合类。因此，要对基本类型进行封装。
但要注意，基本类型更加高效，也更加方便，+-*/等运算符是不支持包装类型的。

#### 15. 内部成员类是如何绑定外围类的？
内部成员类的构造器会隐式以外部类对象作为第一个参数传入其中，内部类持有外围类对象的final引用。



## 2. 关键字
* java中goto是关键字（为了避免使用goto使程序很混乱），但从不使用，因此**也**被称为*保留字* (java中goto和const都是保留字)
* java中使用**循环标签**弥补了goto的一些功能
* true,false,null在java中是**字面常量**（而非关键字）

> [附] java中的关键字列表：
abstract *assert* boolean break byte case catch char class const continue 
default do double else enum extends final finally float for goto if implements
 import instanceof int interface long *native* new package private protected 
public return short static *strictfp* super switch synchronized 
this throw throws *transient* try void *volatile* while

## 3. 标识符
### 标识符要求
* 对于基本Unicode字符集（U+0000~U+10FFFF），使用如下Character两个函数判断: 
```java
public static boolean isJavaIdentifierStart(char ch)
public static boolean isJavaIdentifierPart(char ch)
```
* 对于Unicode增补字符（U+10000~U+10FFFF），使用下面Character两个重载方法：
```java
public static boolean isJavaIdentifierStart(int codePoint)
public static boolean isJavaIdentifierPart(int codePoint)
```
* java标识符定义规则：

1. 首字母满足Character.isJavaIdentifierStart(int codePoint)返回true, 其他字符满足Character.isJavaIdentifierPart(int codePoint)返回ture;
2. 不能是java关键字（包含保留字）或字面常量（true、false、null）
3. 长度在系统支持范围内（Java虚拟机要求）

### $使用出现的问题
由于内部类在经过编译后会产生$，可能会产生意想不到的错误（如：类名和产生的类名重复）。
![](http://www.coding.wang/up/php/upload/default/201505/png/1432516967.png)

### 标识符长度问题[Chap20]
Java虚拟机规范：标识符是有长度限制的。
* class文件中，代表标识符的常量字符串存储在CONSTANT_Utf8_info表中，该表使用**两个**字节描述字符串长度，因此最大长度为2^16-1。
* UTF-8字符可以是单字节、双字节、三字节的，因此，如果存储了单字节以外的UTF-8字符，则标识符长度会减少。（存储在物理内存中的最大长度还是2^16-1不变）


## 4. 特殊字符
1. 最常用特殊字符ASCII对照表：
> 
0a 换行
0d 回车
22 "
27 '
5c \

2. 最常用转义：
>
\n 换行
\r 回车
\t 水平指标
\b 退格
\f 换页
\xxx 八进制转义
\uxxxx Unicode转义 
>> 对于Unicode增补字符集(U+10000~U+10FFFF)必须使用**两个**Unicode转义。如：\u10000 写成 \ud800\udc00

3. 转义字符、8进制转义、Unicode转义可互相转换

4. 编译器对Unicode转义的预处理： 
编译器在编译前扫描源程序代码时会对代码进行预处理，此时优先处理Unicode转义。例如：
将\u000a转换为换行，将\u000d转换为回车，此时可能会造成程序错误。
如果要在程序中输入换行或回车，而不是在源代码上换行或回车，则应该使用\转义或8进制转义。这也是**Unicode转义和其他转义的区别**。

5. Unicode增补字符： 
* Unicode最初是16位的，也就是用一个Unicode转义(\uxxxx)即可以表示。
* Unicode分为：
 * 基本多面语言BMP（U+0000~U+FFFF）
 * 增补字符(U+1 0000~U+10 FFFF)

 > Unicode介绍及中文范围：[http://www.iteye.com/topic/977671](http://www.iteye.com/topic/977671)
 > 
 > 字符常量**不能**表示增补字符
 > 
 > 对于增补字符，要通过两个代码单元进行表示，第一个代码单元来自高代理范围U+D800~U+DBFF（其最高6位是1101 10），第二个代码单元来自低代理范围U+DC00~U+DFFF（其最高6位是1101 11）。
 > 
 > 结合一个Unicode编码(\uxxxx)可以判断它是BMP字符，还是增补字符第一个代码单元，还是增补字符第二个代码单元。如果是BMP字符，则不可能处于高代理范围或低代理范围。
 >
 > 参考维基百科关于BMP描述： [http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane](http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane)
 > ![](http://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Roadmap_to_Unicode_BMP.svg/550px-Roadmap_to_Unicode_BMP.svg.png)
 

## 5. 类型转换

### 整型范围
java中
* byte占1个字节，范围从：-128~127
* char占2个字节，范围从：0x0000~0xffff
* short占2个字节，范围从：0x8000~0x7fff
* int占4个字节，范围从：0x8000 0000~0x7fff ffff (=2G-1，20亿左右)
* long占8个字节，范围从：0x8000 0000 0000 0000~0x7fff ffff ffff ffff

 > 最大值和最小值可以通过其包装类型的MIN_VALUE和MAX_VALUE得到
 > 通过Integer.toHexString(int) Long.toHexString(long)转换成16进制显示

### 转换
* 隐式转换只存在于转换成为范围更大且包含当前类型的类型，即向上转换（如short到int到long），反之不成立；
* 由于byte、char、short三种类型进行**计算**时，结果**总是**为int类型；
* 从byte到char的转换称为扩展收缩转换，相当于先转换为int再转换为char（也可以认为：byte转char是往前面补足byte的符号位）。

>
转换方法：
* 对于大数转小数，从低位截取所需要的位的个数；
* 对于小数转大数，*按小数的符号位*对位进行扩充；


## 6. 浮点类型

### 要点总结：
* 浮点类型数据不精确：1. 对于绝大多数小数无法精确表示； 2. 对于大整数，会存在比较大的间隙。
* float保留7~8个有效数字，double保留15~16个有效数字。因此，对于7位以内的float和15位以内的double整数表示，都是精确的。
* 浮点运算时，不要进行比较操作，因为浮点运算本身是一种近似计算。
* 浮点型转整型：
 1. 转到非long和int的整型，先转换到int，再按浮点型转换规则转换到int，再通过位截取的方式转换到其他整型（byte,short,char）
 2. NaN到0； +/-Infinity或超过int/long极限值，到int/long极限值；当有小数时，向0近似。

## 7. 浮点型结构
### 存储结构及范围：
float: 符号位1位，指数域8位，有效位数域23位；
double：符号位1位，指数域11位，有效位数域52位。

### 整型到浮点型的转换：
分为整数部分和小数部分：
整数部分用除1法
小数部分用乘1法
> 这样就能理解整数可以准确表示而小数不可以了（超过有效位数的整数例外）

### 间隙
Math.ulp(float|double)
Math.nextUp(float|double)
Math.nextAfter(float|double)

### 最近舍入原则：
当没有可表示的浮点值能够表达给定数时，计算机采用**最近舍入原则**，选择最接近的值作为近似值。（如果左右间隙相同，则采用有效位最低位为0的值）


## 8. Java for循环
* 对于数组和List集合类，都可以使用基本的for循环进行遍历。
* 对于数组和**实现了iterable接口**的集合类，可以使用for:进行遍历。
* 对于实现了iterable接口的集合类，for:实际上底层是利用iterator进行遍历的。(根据编译好的字节码判断得出)

对比：加强型for循环（for:）限制强，更简练. 但功能有局限性，更适合顺序访问。

# 二. 运算符与表达式
## 9. 编译器分析时的谈心规则
* 编译器分析源代码是通过从左向右的顺序分析的
* 使用贪心规则：分析代码时尽可能多地匹配有效字符（不考虑语法）

## 10. i++与++i的区别
* i++与++i都是执行到++操作时立即执行+1操作（++操作具有很高的优先级）
* 区别是i++相当于：取i的值，用i的值将表达式代换，++运算正常执行
* 从指令上来说：后置++在执行增值指令iinc前，先将变量值压入栈，执行增值指令后，使用的是之前压入栈的值

> 注意：
(i++)和(++i)的结果是一个数值而不是变量，不能作为左值（因此不能连续++）

## 11. 相除与求余
* 整型+0和-0是同一个值0，内存中也不存在-0
* 浮点型+0.0和-0.0虽然相等（==），但不是同一个值：
 1. 内存中存储不同
 2. 参与运算结果有差异
 3. 有些库认为他们是两个不同的值

* 整数i/0或i%0都会抛出ArithmeticException,而浮点数除法计算永远不会抛出异常，但可能出现NaN，+/-Infinity等结果

## 12. 移位运算
java为整型（byte,short,char,int,long）定义了三种移位操作：左移<<，右移>>,无符号右移>>>（移动太快，符号都丢掉了，哈哈！）

### 真实移位位数
移动的位数只有最低5位（对于int或提升后为int类型的移位）或6位（对于long的移位）是有效的，可以通过如下函数(按位与的方式)计算实际移位：
```java
public static int realShiftNum(int shiftNum) {
	return (0x1f&shiftNum);
}

public static int realShiftNum(long shiftNum) {
	return (int)(0x3f&shiftNum);
}
```

### 移位与乘除2关系
* 对于负数的右移操作，当遇到近似操作时，结果与除以2^n不相等。原因：
除法操作的近似取值都是向0靠近，而右移操作的近似取值都是往-Infinity方向靠近。
* 对于整数右移其他各种情况，左移n位相当于乘以2^n,右移n位相当于除以2^n。

### 永远的-1
-1右移（不论是一位一位地右移还是一次多位的右移）
byte类型和short类型的-1一位一位地无符号右移
> 这里只要理解了类型的转换就容易理解了。

## 13. 条件运算符
举例说明：
```java
k= i>j ? ++i : ++j;
```
* 条件运算符的优先级要比"="高， 它的计算结果是一个值
* 计算结果的类型取决于右边两个语句值的类型，结果类型将取尽量兼容右边两种类型的类型
* 右边两个语句有且仅有一条会被执行

## 14. 运算顺序
### 运算顺序
* java中运算顺序和平台无关，而且在不同操作系统中的表现一致
* java遵循从左向右的运算顺序
	* 在此大前提下根据操作符的优先级确定运算顺序
		* 在优先级相同的基础上根据结合性确定计算顺序
* 注意i++和++i的取值和计算方式（i++是先取值紧接着计算++，参考Chap.10）

### 符合运算
* +=，-=，*=，/=等符合运算相当于对计算进行了一次类型转换。如：
```java
short s=10;
s+=10;
//the same with: s=(short)(s+10)
```
* 符合运算的执行顺序满足上面的运算顺序执行规则

## 15. 变量交换
* 不论是通过传值还是传对象的引用，直接传递两个数到函数都不能实现实参的交换。因为其本质只是改变了形参的引用。
* 将两个对象封装在一个外部对象SwapWrapper或通过数组、集合类引用的方式可以你实现交换。此时外部对象引用不变，而改变的是集合内部元素的引用，因此可以实现交换。
* 交换两个数有三种方式：
 1. 通过临时变量：temp=a;a=b;b=temp;
 2. 通过加减法:a=a+b;b=a-b;a=a-b;(后两个式子后半部分相同)
 3. 通过抑或运算：a=a^b;b=a^b;a=a^b;（三个式子后半部分均相同） *

   > 第三条原理： x ^ y ^ y == x. 

## 16. switch内幕
### switch规则：
* switch规则概述：switch支持常量、变量以及表达式，但其类型必须是：
	1. byte,short,char,int以及他们的包装类型（Byte,Short,Character,Integer）；
	2. 枚举类型；
	3. String类型(从JDK1.7开始支持)。
* case语句：case语句必须为**常量表达式或枚举常量**，必须是能赋给switch表达式的类型；每个case语句后面注意使用break。
* default语句：可以有1个或0个default语句,放在最后。

### switch使用中需要注意的问题：
* 当switch语句中的变量是byte,short,char或其包装类型时，case语句只要是对应变量范围内的字面值即可，不用考虑类型转换，如：
```java
Byte bBox = 1;
switch(bBox) {
case 1:		//编译器进行处理:(byte)1
	System.out.println("byte 1");
	break;
}
```
* 当switch语句是枚举类型变量时，case语句只要是对应枚举类的枚举常量常量名称即可，甚至不用加枚举类限定符（其实也不能加），如：
```java
enum Color3{
	RED,GREEN,BLUE
}
```
```java
//Enum
Color3 color3 = Color3.GREEN;
switch(color3) {
case GREEN:	//非常值得注意的一点是，Color3已经被省略了（而且不能写），非常简洁
	System.out.println("the color is green");
	break;
case RED:
	System.out.println("the color is red");
case BLUE:
	System.out.println("the color is blue");
default:
	System.out.println("unknown color");
	
}
```

### switch的底层实现
switch目前底层只支持byte,short,char,int四种类型
* 包装类型的实现是通过拆箱操作xBox.xValue():x实现的：例如，intBox.intVal();
* 枚举类型通过获取枚举常量序号操作ordinal():int实现的
* String类型通过哈希hashCode():int实现的

# 三. String类

## 17. String + 的实现
### 实现描述
Oracle实现：`new StringBuilder().append("s1").append("s2")`
Eclipse对于String或基本类型为+左边的操作数时实现**才**会不同：`new StringBuilder(String.valueOf("s1")).append("s2")`
> 注意：对于编译时常量字符串的+操作，编译器会提前计算好，而不是在运行时创建StringBuilder

### 最佳实践
* 对于不变的字符串变量，尽量使用final，这样编译器就会尽可能提前计算编译时常量的+操作
* 对于频繁发生的+操作，应考虑使创建StringBuilder避免多次重复创建临时StringBuilder对象。


## 18. String对象的不可修改性
String对象基本描述：String对象是final不可变，所有成员都不可改变。当S**tring类型的变量发生改变**时，其实是从一个String对象引用切换到另一个String对象引用。
String对象是不可变的，调用toUpperCase(),concat(str),substring(2)等成员方法，只是返回了新创建的String对象（而不改变原String对象）
由于String对象的不变性，它是线程安全的，可以跨线程自由共享。

## 19. String最大长度
String 存储字符的成员变量为字符数组： `private final char value[]`，而数组的索引可以是byte,short,char,int等类型，因此String的长度不可能超过0x7fff ffff，这个数值为2G-1.
此外，还可以通过 str.length():int 返回值为int 判断。

可以增加虚拟机堆的大小 从而增加虚拟机可分配的字符数组的最大长度，增加方法如图：
![](http://www.coding.wang/up/php/upload/default/201505/png/1432690948.png)
当参数设为Xmx4G时，最大可以分配长度1365M大小的数组，这个数组所占内存大小已经是2730M了。
当继续增加虚拟机堆大小时，最终可分配2G-1长度的字符数组。

注意：当系统内存比较较紧张时，如果要求分配过大堆内存空间，系统可能不能满足虚拟机请求，最终导致分配内存失败：
![](http://www.coding.wang/up/php/upload/default/201505/png/1432691692.png)

## 20. String字面常量长度极限
1. String字面常量与String类型变量的区别：
String字面常量是由源代码产生，存放在编译好的.class文件的CONSTANT_Utf8_info表中，长度受限于CONSTANT_Utf8_info表的限制。
String变量是java的字节码文件（即.class文件）在java虚拟机中运行时产生，其存放在堆中，长度受限于int最大长度和堆内存大小

2. CONSTANT_Utf8_info表的功能：.java源代码文件经编译后形成.class字节码文件。.class字节码文件使用CONSTANT_Utf8_info表存储各种常量字符串，包括String字面常量、类或接口的权限定名、方法及变量名称、描述符等。

3. CONSTANT_Utf8_info表的结构：
CONSANT_Utf8_info表项由tag、length、bytes三部分组成。
tag占1个字节，值为CONSTANT_Utf8_info（数值1），表示它是一个CONSTANT_Utf8_info表。
length占2个字节，表示字符串长度（因此字符串所占字节数不能超过2^16-1,即不能超过64kB-1）。
bytes占1*n个字节，存放字符串。

4. 各区间字符在CONSTANT_Utf8_info表中的存储：

* ASCII码\u0000~\u007f 占1个字节;
* \u0080~\u07ff 占2个字节;
* \u0800~\uffff 占3个字节；
* Unicode增补字符\u010000~\u10ffff占6个字节（相当于增补字符高字节和低字节分别使用3个字节表示）

> 和char不同，char占2个字节，单个只能表示Unicode的基本字符平面BMP，对于增补字符使用两个char表示。

5. 最大字面量长度：
对于ASCII码，最大长度为64k-1=65535（实际测试为65534）
其他字符根据其在CONSTANT_Utf8_info表中所占位数可能为：2^16/2,2^16/3,2^16/6等。

## 21. equals、hashCode 与 ==
### equals(), hashCode(), ==概述
equals(),hashCode()都定义与Object类，由于Object是其他类（包括异常类Exception等）的基类，因此其他类都有这两个方法。而且在没有重写（Overwrite）的情况下表现与在Object类表现一致：
* equals(): 对象的地址（即引用）是否相等，与==是完全等价的
* hashCode(): 对象地址的哈希值
* == 比较的是对象的地址

> 由于地址会发生变化，hashCode是不可靠的，程序的每次运行hashCode值会发生变化

### String类的equals(), hashCode()重写
String类对equals()方法及hashCode()方法进行了重写，其具体表现如下：
* equals(): 比较值（即字符数组的比较）而不是地址
* hashCode(): 值的哈希而不是地址的哈希

> 注意： StringBuilder, StringBuffer等类没有对equals(), hashCode()这两个方法进行重写，因此其表现和在Object中一致，都是对地址的操作。

### equals(), hashCode() 重写的必要性
* 比较地址，我们可以通过==实现；
* equals()方法比较对象是否相等，在某些集合类判断元素是否存在使用equals()方法进行相等比较（而不是大小比较）操作，如Vector类的contains(obj)。
* Object类的hashCode()是对对象地址的hash，程序的每次运行都会发生改变，使得这个值无论是在持久化还是元素索引查找时都没有价值。因此，需要重写反映出对象所存储的内容的哈希值（而不是地址的哈希值）。HashMap类在取出元素时先通过hashCode()快速找到相同hashCode的值，再通过equals相等比较返回对应的记录。

> 事实上，不要试图将hashCode值进行持久化操作，因为java对hashCode()函数的规范没有要求对程序的多次执行，所得到的hashCode()值必须一致。（应该考虑使用其他hash函数）

### equals()重写规则：
1. 自反性: x.equals(x) == true
2. 对称性: x.equals(y) <=> y.equals(x)
3. 传递性: x.equals(y) && y.equals(z) => x.equals(z)
4. 确定性: x.equals(y)返回的结果确定
5. 排空性: x.equals(null) == false
对于单独的一个类，实现以上规则并不难；对于父子类之间的equals比较，为了实现对称(chen)性，通常需要在子类中对父类对象进行兼容性判断。然而，掺(chan)杂父子类的equals比较不能实现传递性。

### hashCode()重写规则：
1. 如果两个对象equals()相等，那么其hashCode()值一定也是相等的。（这里特别考虑父类和子类比较的情况）
2. 程序同一次运行中，除非对象发生改变导致equals()比较发生变化，否则hashCode()值不应该改变； 对于程序多次运行，hashCode()**可以不同**。
3. 对象内容不同，hashCode尽量不同。

> 注意： 由于父类和子类进行equals()比较时，子类已经对父类采取了兼容措施。而hashCode的本质是尽量反映整个对象的全貌，这样一来，造成son.equals(father)返回true而两个对象的hashCode()值不等的情况。因此：
>> 子类编写equals操作时无需考虑与父类兼容，而在使用过程中，不要对父子类执行等值比较操作。

### 笔试最简回答
问：equals()与==有什么区别：
1. 对于Object类，两者表现一致，都是地址的比较。
2. equals类本质是要对比两个对象是否相等，而不是是不是同一个对象，因此String类对其进行了重写。
3. 其他类也应该进行重写，由于是用于集合操作时，集合操作经常使用对象的equals()方法比较对象是否相等。

## 22. String常量池 与 常量表达式
### String常量池
String类中存在一个存储String字面常量的区域叫做常量池，常量池对于编程人员是透明的。String的两种创建方式本质上有区别：
* 采用文本方法创建String对象时，将自动使用字符串常量池，而且这种方法速度也最快。此时，相同内容的字符串将指向String常量池统一地址。（也就是str1 == str2）
* 采用新建对象方法创建String对象时，将不会使用字符串常量池。这样相同内容的String变量地址不同。（也就是str1 ！= str2）

> 无论如何，String对象本身是不可改变的（因为String类没有暴露相关接口），能改变的是变量的引用指向。

### String常量表达式
对于String字面常量、String常量（final修饰的String对象）和简单类型常量 之间的+操作 结果为String类型，由编译器在编译期间存储在String常量池中。
上述规则中，即使出现了数值计算，只要编译阶段 表达式值能确定的，编译器将计算出值并替换表达式，如果是字符串，将被放到String常量池中：
```java
//编译时能提前计算的均提前完成计算，能“扣留”的字符串均被扣留
System.out.println( (4*5+"str1") == ("20str1") );	//true
System.out.println( (4+5.2+"str1") == ("9.2str1") );	//true
```


# 四. 方法、构造器与变量

## 23. main静态方法探析
main方法是程序的入口，必须声明为public static void，由java虚拟机直接调用。

### 基本用法：

* main方法的声明：
``` java
//before jdk 1.5
public static void main(String[] args) { }
//or 
public static void main(String args[]) { }

//from jdk 1.5 on
public static void main(String... args) { }

```

* main方法的返回：main方法可以向系统返回值，但不是通过方法返回值的方式返回的，而是通过 `System.exit(int status)` 方式返回的。


### 和其他方法类似的特性
重载：可以对main方法重载，但重载的方法都不不能作为程序的入口；
调用：main方法可以被调用；
继承：可以被子类继承（提示：静态方法可以被继承）; 如图，SonInherit过继承得到了SuperInherit的main方法，两个类都具有入口main方法：
![](http://www.coding.wang/up/php/upload/default/201505/png/1432721030.png)
隐藏（重写）：子类自定义自己的main方法以隐藏父类的；
抛出异常：main方法可以抛出异常；
使用类型参数（<T>）：虽然这样做没有意义.


## 24. 方法重载（Overload）

### 重载判断：
* 同一个类中方法名称（cheng）相同而参数列表不同，这种现象叫做方法重载。方法重载与方法的**返回值**和**异常列表**以及**参数化类型的参数**无关。
* 对于泛型化的多个方法（即方法形参 存在 泛化类型的参数），则判断时将泛化类型擦除为泛化类型的基类 进行判断。

### 重载方法的选择
1. 对于基本类型：编译器总是选择调用 需要转换较少的重载方法( 规则：extra -> int -> long -> float -> double, byte -> short)

> 这样可能存在的问题：
> long往float转换时会造成精度损失

2. 对于引用类型：尽量选择更加明确的类（子类比基类更加明确）

3. 当实参是基本类型时，考虑重载方法的顺序为：
 1. 基本类型及其隐式转换
 2. 对应的装箱类型
 3. 对应的可变参数类型

### 选择重载方法的时机
java语言是单分派(Single Dispatch)语言，到底选择哪一个重载方法是根据**引用的静态类型**由**编译器**在编译期间完成的，这叫做**重载的静态绑定**。


## 25. 子类方法方法重写（Overriding）
重写可以实现面向对象中的多态(Polymorphism)，是对继承而来的父类方法的再定义。方法在执行阶段通过动态绑定使得子类对象调用子类的方法 而父类对象调用父类的方法。
### 重写的条件：
子类Sub的某个方法mSub重写父类Super的某个方法mSuper，需要满足以下条件：
 1. mSub和mSuper是**实例**方法
 2. mSub和mSuper名称相同并且继承了父类的mSuper方法(mSuper方法可访问)
 3. mSub的签名是mSuper签名的子签名
 4. mSub返回类型是mSuper返回类型的可替换类 （类型相同（擦除后相同也可以）或mSub的是mSuper的**子类**）
 5. mSub有更高的访问权限 （面向对象中，有一个思想是：子类能做的事父类都能做）
 6. mSub不能抛出更多异常 （是mSuper抛出异常的子集或相同）

> 注释：
子签名：A是B的自签名，则A与B签名相同 或 与“B擦除后”的签名相同。

方法重写应该使用注解@Override以让编译器检查排除错误


## 26. 静态方法与成员变量的隐藏(Shadowing)
### 静态方法隐藏的条件：
子类Sub的某个方法mSub重写父类Super的某个方法mSuper，需要满足以下条件：
 1. mSub与mSuper都是静态方法
 2. mSub和mSuper名称相同并且继承了父类的mSuper方法(mSuper方法可访问)
 3. mSub的签名是mSuper签名的子签名
 4. mSub返回类型是mSuper返回类型的可替换类 （类型相同（擦除后相同也可以）或mSub的是mSuper的**子类**）
 5. mSub有更高的访问权限 （面向对象中，有一个思想是：子类能做的事父类都能做）
 6. mSub不能抛出更多异常 （是mSuper抛出异常的子集或相同）

> 注意：其中只有第1条中规定是静态方法与“子类成员方法的重写”不同

### 成员变量隐藏的条件：
如果Sub中某个成员变量vSub隐藏了父类Super中某个成员变量vSuper，则需要满足以下条件：
 1. vSub和vSuper具有相同名称(cheng)，且子类继承了父类vSuper变量。
 2. 与变量类型、访问权限、实例变量还是静态变量无关。

### 重写与隐藏的区别
 1. 静态方法和成员变量不能重写，只能隐藏。而成员方法不能隐藏，只能重写。
 2. 重写与隐藏的本质区别：重写是执行期间动态绑定（根据对象的实际类型调用方法），而隐藏则是编译期间根据引用类型静态绑定。通俗地讲，如果子类重写了父类的方法，当父类的引用指向子类对象时，父类的引用仍reng然调用子类的方法。而如果子类隐藏了父类的静态方法（或成员变量），父类的引用将调用父类的静态方法（或成员变量）。

> 注意：对于成员变量和静态变量来说，这一点非常重要，为了在父类引用下(面向接口的编程通常是这么做的)访问到正确的成员变量，我们需要使用getters/setters而不是直接访问成员变量和静态变量。（当然，通过成员方法的封装也同时帮助我们访问到正确的静态方法）。[这一点**非常重要**]
> 即使引用值为null，依然可以调用静态方法和静态成员。

## 27. 构造器
构造器用来初始化类实例的成员变量
使用new关键字创建对象**后**由系统系统自动调用

### 构造器与方法的差别：
构造器只能由系统自动调用或**在构造器第一条语句中**使用this(args...),super(args...)调用；
当没有声明构造器时，编译器自动生成一个和类访问权限相同的无参构造器；
构造器**不能被继承**，但在子类创建时，子类构造器如果没有显示调用，则系统首先隐式通过super()调用父类构造器，这个过程是递归进行的，一直会执行到Object的构造器；

### 调用过程
new运算符分配空间并执行对象初始化（包括调用构造器），当对象创建成功时，new将对象的其实地址返回给应用程序。

### 构造器的工作
构造器至少完成以下工作：
 1. 调用父构造器（默认调用父类无参构造器）
 2. 执行实例变量声明初始化
 3. 执行实例初始化块
即使对于空构造器（即里面没有任何内容）或没有声明构造器（即由编译器自动生成的构造器），也会完成以上几个工作。

### 构造器访问权限
一般地，造器不能声明为private, 除非类的创建和继承只发生在当前.java文件

### 关于this指针
在构造器和成员方法中可以使用this指针指代当前对象，其原理是构造器或实例方法将当前对象的指针作为隐含的参数隐式传入构造器或实例方法中。


## 28. 成员变量的不同初始化方式
### 变量的默认值
1. 对于成员变量和静态成员变量，都是有默认值的：
byte (byte)0
short (short)0
char '\u0000'
int 0
long 0L
float 0.0f
double 0.0
boolean false (*)

String以及其他对象的引用 null

2. 对于局部变量，没有默认值
局部变量没有默认值，如果在没有初始化的情况下会产生编译错误。
其中，对于数组，如果使用new创建数组对象，则数组对象中的元素均被赋予初始默认值：
```java
Object[] objs = new Object[100];
System.out.println(objs[10]);	//null
```

3. 成员变量的初始化方式：
成员变量有3中初始化方式：
 1. 在声明处初始化（适用于简单赋值的情况）
 2. 在实例初始化块
 3. 中初始化 （适用于情况复杂的初始化）
 3. 在构造器中初始化 （同上，构造器可传参）

静态变量的初始化方式：
 1. 在声明处初始化（适用于简单赋值的情况）
 2. 在静态初始化块中初始化（适用于情况复杂的初始化）

> 注意： 静态初始化块不仅可以用来初始化静态变量，还经常用来做类在初始化时所需要的准备工作。而且这样的准备工作只**发生一次**。
> 静态变量可以在构造器中赋值，但这不叫初始化，因为每次创建对象都会被调用。

继承关系的初始化：
对于继承关系的父子类，由于父类先于子类构造，父类的成员变量和静态变量将优先被初始化；
子类可以隐藏父类成员变量和静态变量，这种情况下，子类也将初始化这些变量，但不会影响到父类同名变量（子类通过super.var或其父类引用仍然可以使用被隐藏的变量）。

## 29. 初始化顺序与向前引用
### 成员变量和静态成员变量 的初始化顺序：
静态变量初始化（jvm）: 当类没有加载时，首先加载类并执行链接，链接阶段执行静态变量的创建和初始化工作。静态变量初始化的顺序与 静态成员声明初始化和静态初始化块在代码中出现的顺序 一致。
成员变量初始化（jvm）: 执行new创建对象时，new分配堆空间，接着进行实例初始化。 根据声明初始化与实例初始化块顺序执行声明初始化与实例初始化块， **最后**执行构造器。（保证了构造器初始化的权威性）
继承关系下的初始化（jvm）: 加载子类时，先递归加载父类； 实例化子类时，先递归实例化父类。
引用其他类时的初始化(jvm): 如果类在初始化的过程中调用了其他类，在调用处加载其他类；如果涉及到其他类对象的创建，则实例化其他类。

> 注意：以上过程中，加载则意味着首先要递归静态初始化父类；实例化意味着首先要实例初始化父类对象。

### 向前引用
向前引用指的是：引用了 还没有**声明**的成员变量或静态成员变量。可以使用this.var或ClassName.staticVariable进行向前引用（否则会编译报错）。

> 注意：在实际编程中，应该做到先声明，后使用（包括赋值和引用），否则容易造成逻辑混乱。

### 构造器中调用可重写的方法：
子类创建时，先实例化父类，如果父类构造器或实例初始化器中调用了子类重写的方法，就会调用子类的方法，而此时子类还没有进行实例初始化工作，或造成问题甚至错误，这也是一种**向前引用**。
因此，不要在父类实例初始化块中调用可以让子类重写的方法，应该只调用声明为private或final的方法。

### final成员变量初始化
对于值为编译时常量的final成员变量或静态成员变量，它会优先被初始化，无法通过向前引用观察到其默认值。在底层实现上，编译器会直接将其值写到字节码.class文件中，而不是生成变量的符号引用。


# 五. 类与接口

## 30. 基本数据类型与包装类型
java中8种基本数据类型为：byte,char,short,int,long,float,double,boolean。其对应的包装类型依次为：Byte,Character,Short,Integer,Long,Float,Double,Boolean。
基本类型使用更方便，效率也高于包装类型。

### 装箱与拆箱
装箱操作通过静态方法valueOf()实现，如：
```java
Integer iObj = Integer.valueOf(5);
```
拆箱通过成员方法xxval()实现，如：
```java
int i = iObj.intValue();
```

> 注意： 静态方法valueOf不仅可以将拆箱类型转换成对应的包装类型，还可以将字符串转换成对应的包装类型，该方法经过了重载(Overload)，如：
```java
Long lObj = Long.valueOf("23");
System.out.println(lObj);
```

### 包装类型的缓存
由于基本类型的对象和String一样，是不可变的，因此可以通过缓存减少内存中重复的包装类型的量，减少重复创建，从而提升系统性能。
基本数据类型值的缓存范围如下：
Boolean：true,false（全部）
Byte：-128~127（全部）
Character: 0~127 (即ASCII部分)
Short: -128~127
Integer: -128~127（上限可调）
Long: -128~127
Float和Double：无缓存

注意：
* 要使用基本类型的缓存，必须使用valueOf()静态方法，而不能使用构造器创建新的对象。
* 由于java自动装箱底层实现使用的是valueOf()静态方法，因此，自动装箱利用了基本类型的缓存。
* Integer缓存的上限可以通过设定虚拟机属性增加缓存范围：
```
java -Djava.lang.Integer.IntegerCache.high=300
```
![](http://www.coding.wang/up/php/upload/default/201505/png/1433041381.png)

> 注意：
对于server虚拟机，可以使用如下命令进行设置：
```
java -server -XX:AutoBoxCacheMax=300
```


### 装箱与拆箱的选择：
对于+,-,*,/,%等数学运算，只有基本类型直吹，所以，当遇到这些操作时执行拆箱操作。
对于等值比较==或!=运算符，除非左右两边全是包装类型，否则，转换成基本类型。注意，如果是包装类型，比较的是其地址，值比较用equals，包装类型的equals方法均已被重写。


## 31. 数组
数组是一种有序、定长(长度不可调整)、存储相同类型元素 且 可通过下表访问的元素集合。java中数组是类。

### 声明
```java
int[] x,y;	//declare two int arrays x,y
int x[],y;	//declare int array x and int y
```

### 多维数组与交错数组
java中没有真正意义的多维数组，本质都是通过交错数组实现的
1. 多维数组的声明：
```java
int[][] a = new int[2][3]	//两行三类的二维数组
```
2. 交错数组(jagged array)的定义
```java
int[][] b = new int[2][];
b[0][] = new int[4];
b[1][] = new int[5];
```

3. 数组成员
* length属性获取数组长度，此属性为final类型，而且是隐式的，不能通过反射获得。
* 同Object类一样有class静态成员。(注意class是java关键字，此处比较特殊)
* 数组实现了`java.lang.Cloneable`与`java.io.Serializable`接口。
* 方法均继承了Object类，没有自己声明实现的方法。


4. 数组的clone
数组实现的clone为浅复制，仅保证clone方法返回的数组与原数组地址不同。（也就是，数组元素指向相同的对象）
对于多维数组（或交错数组），复制的数组的低维数组引用还指向相同的低维数组对象。

5. 数组输出
* print输出：
boolean: Z@		(*)
byte: B@
short: S@
char: 直接输出对应的字符串		(*)
int: I@
long: J@		(*)
float: F@
double: D@
对象类型：package.CLassName;@		(包括String类、包装类、Object类...)


## 32. 接口

### 接口的默认特征
1. 所有成员变量都是public final static类型。
2. 所有的方法都是public、abstract类型。（java8增加了default）
3. 所有的嵌套类型（类或接口）都是public static类型的。

> 注意：内部接口可以省略关键字static

### 接口中有什么
由于接口类型的引用必然引用一个类，而类有Object的9个方法。
![](http://www.coding.wang/up/php/upload/default/201505/png/1433082525.png)

> 注意：总结起来，Object类的9个成员方法包括：3个wait2个notify3个需要经常重写的（toString,hashCode,equals）以及1个getClass 方法。

### 接口的实现与匿名类
* 通常情况下，实现接口都要使用implements关键字
* 通过匿名类实现接口的方式创建“接口的对象”。具体如下：
```java
public class AnonymousClass {
	static interface MyInterface {
		void say();
	}
	public static void main(String...args) {
		MyInterface inter = new MyInterface() {
			@Override
			public void say() {
				System.out.println("anonymous class say...");
			}
		};
		inter.say();
	}

}
```

### 接口继承接口
* 接口继承允许多重继承：
```java
interface1 extends interface2,interface3 {
}
```

* 接口继承的重写规则与类继承的重写规则一致：如果子接口Sub的某个方法mSub重写了父接口Super的某个方法mSuper，则需要满足以下条件：
1. mSub的签名是mSuper的子签名;
2. mSub的返回类型是mSuper返回类型的可替换类型；
3. mSub不能比mSuper抛出更多受检异常。

* 当多个接口被继承或实现，这些接口中存在相同的静态成员变量，则子接口或实现类需要通过类名限定的方式访问这些静态成员，某则编译阶段异常。

* 如果两个接口中声明了相同名称的方法m，并且两个m没有构成重载，如果某个接口同时继承这两个接口或某个类同时实现这两个接口，则必须存在一种方法：
 1. 其签名同时为两个m方法签名的自签名；
 2. 其返回值同时为两个m方法返回值的可替换类型。


## 33. 嵌套类型

### 静态成员类：
静态成员类的表现和外部类相同。
静态成员类可以访问其外围类的静态部分（包括静态成员和静态成员方法）。

### 内部类：
内部类通常指内部成员类，必须通过外围类的对象才能创建对象。
内部类不能有静态代码（包括静态成员，静态成员方法，静态成员类和嵌套接口）或静态初始化块。（值为编译时常量的final静态成员除外）
内部类可以自由访问外围类和其他内部类、静态成员类。

> 注意：
1. 使用内部类的好处无非是共享外围类的数据和业务逻辑的封装（避免不必要的暴露接口）。
2. 内部类可以自由使用其他内部类，包括静态成员类；而静态成员类不能使用内部类。

### 内部类绑定外围类的实现
内部类包含一个外围类的引用，内部类的构造函数第一个参数隐式传入外围类的对象。

> 注意：通过反编译的代码看不到这个引用，但可以看到构造函数第一个参数传入外围类对象。编译后构造函数代码如下：
```java
final InnerTest this$0;
private InnerTest$Class1(InnerTest t) {
	this$0 = t;
}
```

### 类继承内部类
类继承内部类时，构造函数需要传递内部类的外围类对象并通过该对象显示调用内部类构造函数：
```java
public class InnerInheritance extends Outer.Inner{
	public InnerInheritance(Outer outer) {
		outer.super();
		//编译后相当于: super(outer);
	}
}
```

### 本地内部类（简称本地类）
本地类是声明在实例初始化块、静态初始化块、构造器、方法、静态方法中的类。
本地类类似于局部变量，无访问修饰符和static修饰。
访问约束：本地类不能访问非final的局部变量或方法（构造器）参数。但是，本地类可以通过外围类的成员共享信息。
使用场景：使用场景经常用本地类来实现接口，创建对象，再返回对象。
> 
注意：声明在静态代码块中的本地内部类与实例代码中的本地类的实现不同。前者需要与外围对象进行绑定，也会在本地类中隐式生成一个final的外围类引用；后者不需要绑定，也不会生成外围类引用。


### 匿名内部类
* 匿名类语法如下：
`new Interface1(){}`	或	`new ClassName(){}`
* 匿名类的局限性：只能隐式继承或实现，最多实现一个接口，无构造器。
* 匿名类的使用场景和本地类类似，更适用于只使用一次且逻辑简单的情形。

### 嵌套接口
嵌套接口是声明在类或接口内部的接口，其永远是静态的（因为接口永远是静态的）
嵌套接口如果声明在接口内部，则其也是public的（因为接口成员永远是public的）
实现外围接口时不需要实现嵌套接口。（一般也不实现，接口表达的是一种引用类型）


## 34. 枚举

### C++枚举的问题：
* C++枚举实质是整型，项目中出现“魔数”造成项目难以维护。
* 不同枚举允许互相赋值，逻辑错乱。
* 允许出现枚举值意外的值。

java在枚举出现前使用静态常量（使用public static final修饰），会带来和C++枚举同样的问题，而且可读性比较差。


### java枚举的实现
java枚举底层实现继承java.lang.Enum，所有的枚举都声明为final。每个枚举常量都为public static final。（不能显示继承Enum）

### 访问限制
枚举类实例初始化代码（实例初始化块、实例声明、构造器）不能访问静态成员，因为枚举实例要先于静态初始化代码执行。（对于编译时常量的静态变量除外，即声明为final且值为编译时常量的静态成员。）


## 35. 加载、链接与初始化
使用类时，需要经历以下阶段：
1. 加载
2. 链接
  * 验证
  * 准备
  * 解析
3. 初始化

### 类的加载
将.class字节码文件读入，解析文件结构，创建该类型的Class对象。
java虚拟机启动后，创建一个**启动类加载器**，由其加载**扩展类加载器**与**系统类加载器**。第一个类加载器并非由java语言实现，后面两个类加载器由java语言实现。启动类加载器将系统类加载器的parent设置为扩展类加载器，将扩展类加载器的parent设置为启动类加载器。

### 双亲委派模型
* 当一个类加载器需要加载一个类时，它首先将其委派给其parent（如果不为null），这个过程递归进行，直至启动类加载器。如果启动类加载器可以加载该类，则加载并返回类的Class对象，否则，则原路返回并尝试加载。
* java类库中的类通常由启动类加载器加载，自己写的类一般由系统类加载器加载。


* 每个类加载器所加载的类的路径不同，这里列举他们搜索的路径：

|名称|类名|搜索路径（系统属性而非实际路径）|
|----|:-:|:----------------------:|
|启动类加载器|非java语言实现|sun.boot.class.path|
|扩展类加载器|sun.misc.Launcher$ExtClassLoader|java.ext.dirs|
|系统类加载器|sun.misc.Launcher$AppClassLoader|java.class.path|

根据上面的规则，类加载时首先传递给系统类加载器，在传给扩展类加载器，最终传给启动类加载器。如果启动类加载器可以加载，则加载并返回类的Class对象；否则，传递给扩展类加载器。如果扩展类加载器可以加载，则加载类并返回类的Class对象；否则，则回传给系统类加载器。如果系统类加载器可以加载，则加载类并返回其Class对象；否则，则抛出ClassNotFoundException异常。


### 链接
验证：java类型的二进制结构是否正确
准备：为类的静态变量分配存储空间并设为默认值
解析：将常量池中符号引用（如类名称、成员名称）解析为实际引用地址。

### 初始化
初始化的时机在java虚拟机规范中没有严格的定义，但顺序为加载、链接、初始化。（链接的第三阶段可能在初始化后）

在类初始化时，如果构造器没有调用本地类其他构造器，则所有的实例变量声明初始化和实例初始化块均被复制到构造器内部最上方。
静态成员声明初始化也可以看做被整合进静态初始化块中，语句顺序按照类中出现的顺序。

由于以上原因，造成的影响是：
* 不能在实例初始化块和静态初始化块中使用return；
* 静态初始化块不能抛出异常；实例初始化块可以，但需要在类的所有构造器中捕获相应异常。

### \<init>与\<clinit>
编译器将每个构造器生成一个<init>方法，将实例变量声明初始化和实例初始化块复制到<init>方法内的顶部。因此，所有实例初始化工作全部是在<init>方法中进行的。（如果构造器调用其他构造器，则不会复制，否则会重复执行实例变量初始化和实例初始化块）
同样，编译器将所有的静态初始化语句（静态成员声明初始化与静态初始化块）整合成<clinit>静态方法。（如果没有静态初始化，则不会生成该方法。）

### 类初始化时机
以下情况会初始化类：
1. jvm调用main方法时初始化main方法所在类
2. 创建类对象（new操作、反射、克隆、序列化等）
3. 调用类的静态方法
4. 使用类的静态成员
5. 使用Class类或java.lang.reflect包中某些反射方法
6. 子类初始化时会首先初始化其父类

以下情况不会初始化类：
1. 使用类的引用而没有实例化
2. 外围类中的静态成员类初始化不会导致外围类初始化（如果使用外围类的成员，则会间接导致外围类初始化）
3. ClassLoader的loadCLass方法加载类
4. 调用类中值为编译时常量的静态常量(即final静态变量)。

### 接口初始化时机
当调用接口中静态变量（值为编译时常量的静态常量除外）会初始化接口。
以下情况不会初始化静态变量：
1. 值为编译时常量的静态常量
2. 类初始化时不会初始化其所实现的接口
3. 接口初始化时不会初始化其父接口
4. 接口中的嵌套类型（类、接口）初始化时，不会初始化外围接口。

### 成员变量的间接引用
通过子类限定符引用父类的静态成员变量（即间接引用），不会初始化子类，会初始化成员实际所在类。


## 36. 类型及其成员的选择

### 重写、隐藏与遮蔽
重写发生在类继承关系中，子类中重新声明父类中某个实例成员方法。
隐藏也发生在类继承关系中，针对静态成员或静态成员方法。
遮蔽发生在某作用域中，同时出现了相同名称的类型或类型成员，某类型或类型成员会遮蔽另一个类型或类型成员。

### 类型选择的顺序
1. 当前类型
2. 嵌套类型
3. 明确导入（单一导入）类型
4. 本包中的其他类型
5. 按需导入（使用*导入）类型

> 注意：如果在相同优先级内出现相同类型的定义，则产生编译错误。
> 有一种有趣的现象，嵌套类和外围类同名，这是**不允许**的

### 变量的选择
1. 最小代码块
2. 方法形参（parameters）
3. 外围语句块
4. 类、接口成员变量 -> 父类继承的类、接口成员变量
5. 如果变量名称出现在嵌套类型中，则：
 * 如果是本地类或匿名类，则执行1~4步骤。
 * 如果是成员类，则执行步骤4。
 * 如果多层嵌套，则递归执行5。
6. 明确静态导入的静态成员。
7. 按需静态导入的静态成员。

> 注意：
对于以上6,7步骤，静态导入类静态成员的语法如下：
```java
import static package.ClassName.*;	//明确导入
import static package.ClassName.field1;	//按需导入
```

> 变量选择可能因为是否static、类型不匹配造成中断。

### 方法的选择
方法的选择与变量的选择顺序基本是一致的：
1. 当前类声明的方法
2. 父类继承的所有方法
3. 如果方法调用语句发生在嵌套类型中，搜索外围类方法，直至顶层外围类
4. 明确静态导入的方法
5. 按需静态导入的方法

> 注意：
对于以上4,5步骤，静态导入类静态方法的语法如下：
```java
import static package.ClassName.*;
import static package.ClassName.method1;
```
> 方法的选择可能因为是否static、参数列表不匹配而造成中断。


### 模糊
对某一名称的使用会造成歧义，不能确定其是否是类名、报名或变量名。通常在规范命名的情况下这种情况不会发生。
名称解析优先级如下：
> 变量名 > 类型名 > 包名























